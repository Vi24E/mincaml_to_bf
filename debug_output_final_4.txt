   Compiling mincaml_to_bf v0.1.0 (/Users/koharayu/Desktop/大学/cpu実験/mincaml_to_bf)
warning: unused import: `self`
 --> src/intermediate.rs:2:22
  |
2 | use crate::closure::{self, Prog as ClosureProg};
  |                      ^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::convert::TryInto`
 --> src/virtual_interpreter.rs:2:5
  |
2 | use std::convert::TryInto;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Write` and `self`
 --> src/virtual_interpreter.rs:3:15
  |
3 | use std::io::{self, Write};
  |               ^^^^  ^^^^^

warning: unused variable: `push_ops`
   --> src/blocked.rs:154:29
    |
154 |                     let mut push_ops: Vec<Term> = Vec::new();
    |                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_push_ops`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> src/blocked.rs:154:25
    |
154 |                     let mut push_ops: Vec<Term> = Vec::new();
    |                         ----^^^^^^^^
    |                         |
    |                         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `i`
   --> src/blocked.rs:472:14
    |
472 |         for (i, (arg, ty)) in fundef.args.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `x`
   --> src/intermediate.rs:150:32
    |
150 |             BlockedTerm::GetSp(x) => self.bind_atom(Atom::GetSp, dest, next),
    |                                ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: value assigned to `block_count` is never read
   --> src/intermediate.rs:360:13
    |
360 |     let mut block_count = 0;
    |             ^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `var_count` is never read
   --> src/intermediate.rs:361:13
    |
361 |     let mut var_count = 0; // Max var count across all functions (for global stats, if needed)
    |             ^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `entry_label`
   --> src/intermediate.rs:356:5
    |
356 |     entry_label: &id::L,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_entry_label`

warning: variable does not need to be mutable
   --> src/intermediate.rs:378:9
    |
378 |     let mut map_args = |func_name: &str, map: &mut HashMap<id::T, usize>, count: &mut usize| {
    |         ----^^^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `e1`
   --> src/k_normal.rs:101:28
    |
101 |         syntax::Syntax::Eq(e1, e2) | syntax::Syntax::LE(e1, e2) => g(
    |                            ^^                           ^^
    |
help: if this is intentional, prefix it with an underscore
    |
101 |         syntax::Syntax::Eq(_e1, e2) | syntax::Syntax::LE(_e1, e2) => g(
    |                            +                             +

warning: unused variable: `e2`
   --> src/k_normal.rs:101:32
    |
101 |         syntax::Syntax::Eq(e1, e2) | syntax::Syntax::LE(e1, e2) => g(
    |                                ^^                           ^^
    |
help: if this is intentional, prefix it with an underscore
    |
101 |         syntax::Syntax::Eq(e1, _e2) | syntax::Syntax::LE(e1, _e2) => g(
    |                                +                             +

warning: unused variable: `args`
   --> src/k_normal.rs:209:25
    |
209 |                     let args: Vec<id::T> = Vec::new();
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: unused variable: `entry_idx`
   --> src/virtual.rs:139:9
    |
139 |     let entry_idx = *block_map.get(&prog.entry).unwrap(); // Should be 1
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_entry_idx`

warning: unused variable: `i`
   --> src/virtual.rs:141:10
    |
141 |     for (i, block) in sorted_blocks {
    |          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `l`
   --> src/virtual.rs:429:24
    |
429 |         Atom::ExtArray(l) => {
    |                        ^ help: if this is intentional, prefix it with an underscore: `_l`

warning: unused variable: `self_ptr`
   --> src/virtual_interpreter.rs:165:25
    |
165 |                     let self_ptr = self.read_int(sp - 32);
    |                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_self_ptr`

warning: unused variable: `addr`
   --> src/virtual_interpreter.rs:205:34
    |
205 |             Operation::InputByte(addr) => {
    |                                  ^^^^ help: if this is intentional, prefix it with an underscore: `_addr`

warning: method `get_type` is never used
  --> src/blocked.rs:61:8
   |
60 | impl Term {
   | --------- method in this implementation
61 |     fn get_type(&self) -> Type {
   |        ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `closure_map` is never read
   --> src/blocked.rs:107:5
    |
105 | struct Converter {
    |        --------- field in this struct
106 |     blocks: Vec<Block>,
107 |     closure_map: HashMap<id::T, (id::L, Vec<id::T>)>, // Var -> (Label, FVs)
    |     ^^^^^^^^^^^

warning: method `new_block_id` is never used
   --> src/blocked.rs:129:8
    |
114 | impl Converter {
    | -------------- method in this implementation
...
129 |     fn new_block_id(&self) -> id::L {
    |        ^^^^^^^^^^^^

warning: function `add_point` is never used
   --> src/emit.rs:494:4
    |
494 | fn add_point(bf_code: &mut String, n: u32) {
    |    ^^^^^^^^^

warning: function `sub_point` is never used
   --> src/emit.rs:501:4
    |
501 | fn sub_point(bf_code: &mut String, n: u32) {
    |    ^^^^^^^^^

warning: function `iszero` is never used
   --> src/emit.rs:674:4
    |
674 | fn iszero(bf_code: &mut String, current_ptr: &mut u32, register: u32, buffer: u32, dest: u32) {
    |    ^^^^^^

warning: `mincaml_to_bf` (lib) generated 25 warnings (run `cargo fix --lib -p mincaml_to_bf` to apply 5 suggestions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.99s
     Running `target/debug/mincaml_to_bf -s test2.ml`
DEBUG: LetRec func: k_cont.53, args: [("Tu48", Int), ("self_env.54", Int)], current_self: Some("self_env.54")
DEBUG: LetRec func: k_cont.50, args: [("Tu49", Int), ("self_env.51", Int)], current_self: Some("self_env.51")
DEBUG: LetRec func: k_if.28, args: [("Ti27", Int), ("self_env.29", Int)], current_self: Some("self_env.29")
DEBUG: Check Get(self_env.29, Ti30). current_self=Some("self_env.29")
DEBUG: Intercepted Get(self_env.29, Ti30) -> Var(k.25)
DEBUG: LetRec func: k_cont.41, args: [("Tu32", Int), ("self_env.42", Int)], current_self: Some("self_env.42")
DEBUG: Check Get(self_env.42, Ti46). current_self=Some("self_env.42")
DEBUG: Intercepted Get(self_env.42, Ti46) -> Var(n.13)
DEBUG: Check Get(self_env.42, Ti45). current_self=Some("self_env.42")
DEBUG: Intercepted Get(self_env.42, Ti45) -> Var(k_cls.31)
DEBUG: Check Get(self_env.42, Ti44). current_self=Some("self_env.42")
DEBUG: Intercepted Get(self_env.42, Ti44) -> Var(k.11)
DEBUG: Check Get(self_env.42, Ti43). current_self=Some("self_env.42")
DEBUG: Intercepted Get(self_env.42, Ti43) -> Var(fib_alt.12)
DEBUG: LetRec func: k_cont.35, args: [("Tu33", Int), ("self_env.36", Int)], current_self: Some("self_env.36")
DEBUG: Check Get(self_env.36, Ti39). current_self=Some("self_env.36")
DEBUG: Intercepted Get(self_env.36, Ti39) -> Var(Ti6.17)
DEBUG: Check Get(self_env.36, Ti38). current_self=Some("self_env.36")
DEBUG: Intercepted Get(self_env.36, Ti38) -> Var(k_cls.31)
DEBUG: Check Get(self_env.36, Ti37). current_self=Some("self_env.36")
DEBUG: Intercepted Get(self_env.36, Ti37) -> Var(k.11)
DEBUG: Intermediate Prog:
Entry: main
Block Count: 10
Var Count: 68
Block Map:
  prelude: 0
  k_cont.50: 1
  k_cont.53: 2
  main: 3
  k_if.28: 4
  k_cont.35: 5
  k_cont.41: 6
  block.83: 7
  block.84: 8
  fib_alt.12: 9
Var Map:
  Tu49: 0
  self_env.51: 1
  Tu56: 2
  Tu48: 3
  self_env.54: 4
  Ti2.24: 5
  k_cls.52: 6
  Tu58: 7
  Tu57: 8
  k.11: 9
  Tu62: 10
  fib_alt.12: 11
  Ti1.23: 12
  k_cls.55: 13
  Tu61: 14
  Tu60: 15
  Tu59: 16
  Ti27: 17
  self_env.29: 18
  k.25: 19
  Ti30: 20
  Tu64: 21
  Tu63: 22
  Tu33: 23
  self_env.36: 24
  Ti6.17: 25
  k_cls.31: 26
  Ti39: 27
  Ti38: 28
  Ti37: 29
  Ti9.20: 30
  Ti10.21: 31
  x.22: 32
  Ti34: 33
  Tu68: 34
  Tu67: 35
  Tu32: 36
  self_env.42: 37
  n.13: 38
  Ti46: 39
  Ti45: 40
  Ti44: 41
  Ti43: 42
  Ti7.18: 43
  Ti8.19: 44
  Tu74: 45
  Tu73: 46
  Tu72: 47
  k_cls.40: 48
  Tu71: 49
  Tu70: 50
  Tu69: 51
  Tu66: 52
  Tu65: 53
  Ti4.15: 54
  Ti5.16: 55
  Tu81: 56
  Tu80: 57
  Tu79: 58
  Tu78: 59
  k_cls.47: 60
  Tu77: 61
  Tu76: 62
  Tu75: 63
  self_env.26: 64
  Ti3.14: 65
  Tu82: 66
prelude:
  Jump(main)
k_cont.50:
  Let (Tu49: int) = Pop in
  Let (self_env.51: int) = Pop in
  Let (Tu56: unit) = Push(Tu49) in
  Jump(halt)
k_cont.53:
  Let (Tu48: int) = Pop in
  Let (self_env.54: int) = Pop in
  Let (Ti2.24: int) = Tu48 in
  Let (k_cls.52: (int -> unit)) = LoadLabel(k_cont.50) in
  Let (Tu58: unit) = Push(Ti2.24) in
  Let (Tu57: unit) = Push(k_cls.52) in
  Jump(min_caml_print_int)
main:
  Let (k.11: int) = 42 in
  Let (Tu62: unit) = Push(k.11) in
  Let (fib_alt.12: (int -> int)) = LoadLabel(fib_alt.12) in
  Let (Ti1.23: int) = 10 in
  Let (k_cls.55: (int -> unit)) = LoadLabel(k_cont.53) in
  Let (Tu61: unit) = Push(Ti1.23) in
  Let (Tu60: unit) = Push(k_cls.55) in
  Let (Tu59: unit) = Push(fib_alt.12) in
  JumpVar(fib_alt.12)
k_if.28:
  Let (Ti27: int) = Pop in
  Let (self_env.29: int) = Pop in
  Let (k.25: int) = Pop in
  Let (Ti30: int) = 1 in
  Let (k.25: int) = k.25 in
  Let (Tu64: unit) = Push(Ti27) in
  Let (Tu63: unit) = Push(k.25) in
  JumpVar(k.25)
k_cont.35:
  Let (Tu33: int) = Pop in
  Let (self_env.36: int) = Pop in
  Let (Ti6.17: int) = Pop in
  Let (k_cls.31: int) = Pop in
  Let (k.11: int) = Pop in
  Let (Ti39: int) = 1 in
  Let (Ti6.17: int) = Ti6.17 in
  Let (Ti38: int) = 2 in
  Let (k_cls.31: int) = k_cls.31 in
  Let (Ti37: int) = 3 in
  Let (k.11: int) = k.11 in
  Let (Ti9.20: int) = Tu33 in
  Let (Ti10.21: int) = Ti6.17 + Ti9.20 in
  Let (x.22: int) = Ti10.21 + k.11 in
  Let (Ti34: int) = x.22 + x.22 in
  Let (Tu68: unit) = Push(Ti34) in
  Let (Tu67: unit) = Push(k_cls.31) in
  JumpVar(k_cls.31)
k_cont.41:
  Let (Tu32: int) = Pop in
  Let (self_env.42: int) = Pop in
  Let (n.13: int) = Pop in
  Let (k_cls.31: int) = Pop in
  Let (k.11: int) = Pop in
  Let (fib_alt.12: int) = Pop in
  Let (Ti46: int) = 1 in
  Let (n.13: int) = n.13 in
  Let (Ti45: int) = 2 in
  Let (k_cls.31: int) = k_cls.31 in
  Let (Ti44: int) = 3 in
  Let (k.11: int) = k.11 in
  Let (Ti43: int) = 4 in
  Let (fib_alt.12: int) = fib_alt.12 in
  Let (Ti6.17: int) = Tu32 in
  Let (Ti7.18: int) = 2 in
  Let (Ti8.19: int) = n.13 - Ti7.18 in
  Let (Tu74: unit) = Push(k.11) in
  Let (Tu73: unit) = Push(k_cls.31) in
  Let (Tu72: unit) = Push(Ti6.17) in
  Let (k_cls.40: (int -> unit)) = LoadLabel(k_cont.35) in
  Let (Tu71: unit) = Push(Ti8.19) in
  Let (Tu70: unit) = Push(k_cls.40) in
  Let (Tu69: unit) = Push(fib_alt.12) in
  JumpVar(fib_alt.12)
block.83:
  Let (Tu66: unit) = Push(n.13) in
  Let (Tu65: unit) = Push(k_cls.31) in
  JumpVar(k_cls.31)
block.84:
  Let (Ti4.15: int) = 1 in
  Let (Ti5.16: int) = n.13 - Ti4.15 in
  Let (Tu81: unit) = Push(fib_alt.12) in
  Let (Tu80: unit) = Push(k.11) in
  Let (Tu79: unit) = Push(k_cls.31) in
  Let (Tu78: unit) = Push(n.13) in
  Let (k_cls.47: (int -> unit)) = LoadLabel(k_cont.41) in
  Let (Tu77: unit) = Push(Ti5.16) in
  Let (Tu76: unit) = Push(k_cls.47) in
  Let (Tu75: unit) = Push(fib_alt.12) in
  JumpVar(fib_alt.12)
fib_alt.12:
  Let (self_env.26: int) = Pop in
  Let (k.25: (unit -> unit)) = Pop in
  Let (n.13: int) = Pop in
  Let (Ti3.14: int) = 1 in
  Let (Tu82: unit) = Push(k.25) in
  Let (k_cls.31: int) = LoadLabel(k_if.28) in
  IfLE(n.13, Ti3.14, Goto(block.83), Goto(block.84))

DEBUG: Starting virtual::f
DEBUG: Virtual Prog generated. Blocks: 10
DEBUG: Virtual Program:
Virtual Prog:
Block Count: 10
Var Count: 68
Block 0:
  Jump(3)
Block 1:
  Pop(150)
  Pop(182)
  Push(150)
  SetImm(214, 0)
  CallExternal(halt)
Block 2:
  Pop(246)
  Pop(278)
  MoveData(310, 246, 32)
  SetImm(342, 1)
  Push(310)
  SetImm(374, 0)
  Push(342)
  SetImm(406, 0)
  CallExternal(min_caml_print_int)
Block 3:
  SetImm(438, 42)
  Push(438)
  SetImm(470, 0)
  SetImm(502, 9)
  SetImm(534, 10)
  SetImm(566, 2)
  Push(534)
  SetImm(598, 0)
  Push(566)
  SetImm(630, 0)
  Push(502)
  SetImm(662, 0)
  JumpVar(502)
Block 4:
  Pop(694)
  Pop(726)
  Pop(758)
  SetImm(790, 1)
  MoveData(758, 758, 32)
  Push(694)
  SetImm(822, 0)
  Push(758)
  SetImm(854, 0)
  JumpVar(758)
Block 5:
  Pop(886)
  Pop(918)
  Pop(950)
  Pop(982)
  Pop(438)
  SetImm(1014, 1)
  MoveData(950, 950, 32)
  SetImm(1046, 2)
  MoveData(982, 982, 32)
  SetImm(1078, 3)
  MoveData(438, 438, 32)
  MoveData(1110, 886, 32)
  Add(1142, 950, 1110)
  Add(1174, 1142, 438)
  Add(1206, 1174, 1174)
  Push(1206)
  SetImm(1238, 0)
  Push(982)
  SetImm(1270, 0)
  JumpVar(982)
Block 6:
  Pop(1302)
  Pop(1334)
  Pop(1366)
  Pop(982)
  Pop(438)
  Pop(502)
  SetImm(1398, 1)
  MoveData(1366, 1366, 32)
  SetImm(1430, 2)
  MoveData(982, 982, 32)
  SetImm(1462, 3)
  MoveData(438, 438, 32)
  SetImm(1494, 4)
  MoveData(502, 502, 32)
  MoveData(950, 1302, 32)
  SetImm(1526, 2)
  Sub(1558, 1366, 1526)
  Push(438)
  SetImm(1590, 0)
  Push(982)
  SetImm(1622, 0)
  Push(950)
  SetImm(1654, 0)
  SetImm(1686, 5)
  Push(1558)
  SetImm(1718, 0)
  Push(1686)
  SetImm(1750, 0)
  Push(502)
  SetImm(1782, 0)
  JumpVar(502)
Block 7:
  Push(1366)
  SetImm(1814, 0)
  Push(982)
  SetImm(1846, 0)
  JumpVar(982)
Block 8:
  SetImm(1878, 1)
  Sub(1910, 1366, 1878)
  Push(502)
  SetImm(1942, 0)
  Push(438)
  SetImm(1974, 0)
  Push(982)
  SetImm(2006, 0)
  Push(1366)
  SetImm(2038, 0)
  SetImm(2070, 6)
  Push(1910)
  SetImm(2102, 0)
  Push(2070)
  SetImm(2134, 0)
  Push(502)
  SetImm(2166, 0)
  JumpVar(502)
Block 9:
  Pop(2198)
  Pop(758)
  Pop(1366)
  SetImm(2230, 1)
  Push(758)
  SetImm(2262, 0)
  SetImm(982, 4)
  Sub(2294, 1366, 2230)
  JumpIfLE(2294, 7, 8)

DEBUG: Executing Block 0
DEBUG: Executing Block 2
0
Simulation Error: print_int continuation closure is NULL (0)
