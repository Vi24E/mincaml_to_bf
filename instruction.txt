# 実装方針オーバービュー：Global Register & Physical Stack Architecture

## 1. アーキテクチャの核心
本プロジェクトは、mincamlからBrainfuckへのトランスコンパイルにおいて、**「Global Register（固定アドレス変数）」と「Physical Stack（テープ末尾の動的領域）」を組み合わせたハイブリッド方式**を採用します。

* **Global Register (計算領域):**
    * すべての変数（引数、ローカル変数）を一意な固定アドレス（ID）にマッピングします。
    * 加算、減算、参照などの**計算はすべてこの固定アドレス上で行います**。これにより、Brainfuck上でのポインタ移動コストを最小化し、静的な最適化（`current_ptr`の追跡）を有効にします。
* **Physical Stack (保存領域):**
    * 関数呼び出し時の引数渡し、およびコンテキスト（変数の値）の退避場所として機能します。
    * Brainfuckのテープの末尾（未使用領域）を利用した単純なLIFOスタックです。
    * **計算には使いません。** 値の「退避（Push）」と「復帰（Pop）」にのみ使用します。

## 2. メモリレイアウト
Brainfuckのテープ全体を以下のように区画分けして管理します。

| 領域名 | 役割 | アクセス方式 |
| :--- | :--- | :--- |
| **Flags** | ブロック実行制御用のフラグ領域 | 固定アドレス |
| **Registers** | 計算用の一時レジスタ (Temp) | 固定アドレス |
| **Variables** | **全変数の固定住居 (Global Registers)** | **固定アドレス** |
| **Stack** | 引数・コンテキストの積み上げ場所 | **動的 (テープ末尾)** |

## 3. データフローと実行モデル

このモデルでは、関数呼び出しは「RegisterからStackへのデータ移動」、関数開始は「StackからRegisterへのデータ移動」として表現されます。

### A. 関数呼び出し (Caller Side)
1.  **Push:** 次の関数に必要な引数（CPS変換により、継続やキャプチャされた環境もすべて引数に含まれる）を、それぞれの固定アドレス（Variables領域）から読み出し、Stack（テープ末尾）へコピーします。
2.  **Jump:** 対象のブロックへ制御を移します。

### B. 関数開始 (Callee Side)
1.  **Pop:** 関数が開始した瞬間、引数はStackのトップに積まれています。これらをLIFO順で取り出し、**自身の対応する固定アドレス（Variables領域）へ移動（上書き）**します。
2.  **Compute:** 以降、変数はすべて固定アドレスにあるものとして計算を行います。再帰呼び出しで変数が上書きされる前には、上記「A」のプロセスによって必要な値が再びStackへ退避されます。

## 4. コンポーネント別の変更点

### `intermediate.rs` / `blocked.rs` (IR変換)
* **役割:** 抽象的な「関数呼び出し」を、具体的な「Push/Pop命令」へ分解します。
* **変更点:**
    * 関数定義の先頭に、引数の数だけ `Pop(arg_var)` を挿入します。
    * 関数呼び出し（`App`）の直前に、引数の数だけ `Push(arg_var)` を挿入します。
    * `SetArgs`, `GetStack` などの抽象命令を廃止し、単純な `Atom::Push`, `Atom::Pop` に統一します。

### `virtual.rs` (アドレス解決)
* **役割:** 変数IDを具体的なBrainfuckテープ上のアドレスへマッピングします。
* **変更点:**
    * SP（スタックポインタ）変数の管理ロジックを削除します。
    * `Operation::Push(src_addr)`: 固定アドレス `src_addr` の値をテープ末尾へコピーする命令へ変換。
    * `Operation::Pop(dest_addr)`: テープ末尾の値を固定アドレス `dest_addr` へコピーする命令へ変換。

### `emit.rs` (コード生成)
* **役割:** Brainfuckコード（`><+-.,[]`）を出力します。
* **変更点:**
    * 既存の `Push/Pop` 実装（LIFOスタック操作）をそのまま利用します。
    * `current_ptr` による静的な位置追跡は、Variables領域（固定）へのアクセスにおいて引き続き有効に機能させ、最適化を維持します。

## 5. `fib n` における挙動例

再帰関数 `fib` がこのモデルでどう動くかのトレースです。

1.  **Call `fib(10)`:**
    * Callerが `10` をStackへ **Push**。
    * Stack: `[..., 10]`
2.  **Enter `fib`:**
    * 引数 `n` に対応する固定アドレス `ADDR_N` へ、Stackから **Pop**。
    * Stack: `[...]` / Register: `ADDR_N = 10`
3.  **Recursive Call `fib(9)`:**
    * (CPS変換により、継続 `k` と環境 `n=10` が引数になる)
    * `n` (値10) をStackへ **Push**。
    * `n-1` (値9) をStackへ **Push**。
    * Stack: `[..., 10, 9]`
4.  **Enter `fib` (Re-entry):**
    * `ADDR_N` へ **Pop** (値9)。
    * `ADDR_N` へ **Pop** (値10) ※継続用変数の場合
    * Register `ADDR_N` は `9` で上書きされるが、必要なデータはStack経由で渡されているため安全。

この方針により、Brainfuck特有の制約（ポインタ移動コスト、ランダムアクセスの難しさ）を回避しつつ、mincamlの全機能（再帰、クロージャ）をサポートします。